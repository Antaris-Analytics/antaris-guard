"""
Behavioral analysis — track patterns across sessions.

Detects escalation patterns, burst behavior, and coordinated attacks
by analyzing interaction sequences rather than individual inputs.

All deterministic, zero dependencies, file-based persistence.
"""

import json
import logging
import os
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from .utils import atomic_write_json

logger = logging.getLogger(__name__)


@dataclass
class BehaviorAlert:
    """Alert generated by behavioral analysis."""
    alert_type: str  # 'escalation', 'burst', 'pattern_shift', 'probe_sequence'
    severity: str    # 'low', 'medium', 'high', 'critical'
    source_id: str
    description: str
    evidence: List[Dict[str, Any]]
    timestamp: float


class BehaviorAnalyzer:
    """
    Analyze interaction patterns across sessions.
    
    Detects:
    - **Escalation**: Source starts safe, gradually tests boundaries
    - **Burst attacks**: Rapid-fire suspicious/blocked requests
    - **Probe sequences**: Systematic testing of different attack vectors
    - **Pattern shifts**: Sudden change in behavior from established baseline
    
    Features:
    - Per-source interaction windows (configurable)
    - Sliding window analysis for burst detection
    - Escalation detection across time
    - File-based persistence of interaction history
    """
    
    # Window sizes
    INTERACTION_WINDOW = 100     # Keep last N interactions per source
    BURST_WINDOW_SECONDS = 60    # Time window for burst detection
    BURST_THRESHOLD = 5          # Suspicious+ requests in window = burst
    
    # Escalation detection
    ESCALATION_WINDOW = 20       # Check last N interactions for escalation
    ESCALATION_RATIO = 0.5       # If last half has 50%+ more threats than first half
    
    # Probe detection
    PROBE_UNIQUE_THRESHOLD = 5   # Different attack types in window = probing
    PROBE_WINDOW = 50            # Interactions to check for probing
    
    # Alert deduplication
    ALERT_COOLDOWN_SECONDS = 300  # Suppress duplicate alerts within 5 minutes
    
    def __init__(self, store_path: str = "./behavior_store.json"):
        """
        Initialize BehaviorAnalyzer.
        
        Args:
            store_path: Path to persistence file
        """
        self.store_path = store_path
        # source_id → list of interaction records
        self.interactions: Dict[str, list] = {}
        # (source_id, alert_type) → last alert timestamp (in-memory only)
        self._last_alerts: Dict[tuple, float] = {}
        self._load()
    
    def _load(self) -> None:
        """Load interaction history from disk."""
        if not os.path.exists(self.store_path):
            return
        try:
            with open(self.store_path, 'r') as f:
                data = json.load(f)
            self.interactions = data.get('interactions', {})
        except (json.JSONDecodeError, TypeError):
            pass
    
    def _save(self) -> None:
        """Save interaction history to disk (atomic write)."""
        data = {
            'interactions': self.interactions,
            'saved_at': time.time(),
        }
        try:
            atomic_write_json(self.store_path, data, indent=None)
        except OSError:
            # atomic_write_json already logged the error
            pass
    
    def record(self, source_id: str, threat_level: str,
               matched_patterns: List[str] = None,
               score: float = 0.0) -> List[BehaviorAlert]:
        """
        Record an interaction and check for behavioral patterns.
        
        Args:
            source_id: Source identifier
            threat_level: "safe", "suspicious", or "blocked"
            matched_patterns: List of pattern types that matched
            score: Threat score from guard analysis
            
        Returns:
            List of BehaviorAlerts detected (empty if none)
        """
        now = time.time()
        
        record = {
            'timestamp': now,
            'threat_level': threat_level,
            'patterns': matched_patterns or [],
            'score': score,
        }
        
        if source_id not in self.interactions:
            self.interactions[source_id] = []
        
        history = self.interactions[source_id]
        history.append(record)
        
        # Trim to window size
        if len(history) > self.INTERACTION_WINDOW:
            self.interactions[source_id] = history[-self.INTERACTION_WINDOW:]
            history = self.interactions[source_id]
        
        # Run behavioral checks (with deduplication)
        alerts = []
        
        burst = self._check_burst(source_id, history, now)
        if burst and self._should_alert(source_id, burst.alert_type, now):
            alerts.append(burst)
        
        escalation = self._check_escalation(source_id, history)
        if escalation and self._should_alert(source_id, escalation.alert_type, now):
            alerts.append(escalation)
        
        probe = self._check_probe_sequence(source_id, history)
        if probe and self._should_alert(source_id, probe.alert_type, now):
            alerts.append(probe)
        
        self._save()
        return alerts
    
    def _should_alert(self, source_id: str, alert_type: str, now: float) -> bool:
        """Check if alert should fire (cooldown deduplication)."""
        key = (source_id, alert_type)
        last = self._last_alerts.get(key, 0.0)
        if now - last < self.ALERT_COOLDOWN_SECONDS:
            return False
        self._last_alerts[key] = now
        return True
    
    def _check_burst(self, source_id: str, history: list,
                     now: float) -> Optional[BehaviorAlert]:
        """Detect rapid-fire suspicious/blocked requests."""
        cutoff = now - self.BURST_WINDOW_SECONDS
        recent = [r for r in history if r['timestamp'] >= cutoff]
        
        threat_count = sum(
            1 for r in recent
            if r['threat_level'] in ('suspicious', 'blocked')
        )
        
        if threat_count >= self.BURST_THRESHOLD:
            return BehaviorAlert(
                alert_type='burst',
                severity='high',
                source_id=source_id,
                description=f'{threat_count} threat events in {self.BURST_WINDOW_SECONDS}s window',
                evidence=[{
                    'window_seconds': self.BURST_WINDOW_SECONDS,
                    'threat_count': threat_count,
                    'total_in_window': len(recent),
                }],
                timestamp=now,
            )
        return None
    
    def _check_escalation(self, source_id: str,
                          history: list) -> Optional[BehaviorAlert]:
        """Detect gradual escalation from safe to threatening."""
        if len(history) < self.ESCALATION_WINDOW:
            return None
        
        window = history[-self.ESCALATION_WINDOW:]
        mid = len(window) // 2
        first_half = window[:mid]
        second_half = window[mid:]
        
        def threat_ratio(records):
            if not records:
                return 0.0
            threats = sum(1 for r in records if r['threat_level'] != 'safe')
            return threats / len(records)
        
        first_ratio = threat_ratio(first_half)
        second_ratio = threat_ratio(second_half)
        
        # Escalation: second half has significantly more threats
        if second_ratio > first_ratio + self.ESCALATION_RATIO and second_ratio > 0.3:
            return BehaviorAlert(
                alert_type='escalation',
                severity='high',
                source_id=source_id,
                description=f'Threat ratio escalated from {first_ratio:.0%} to {second_ratio:.0%}',
                evidence=[{
                    'first_half_ratio': round(first_ratio, 3),
                    'second_half_ratio': round(second_ratio, 3),
                    'window_size': self.ESCALATION_WINDOW,
                }],
                timestamp=time.time(),
            )
        return None
    
    def _check_probe_sequence(self, source_id: str,
                              history: list) -> Optional[BehaviorAlert]:
        """Detect systematic testing of different attack vectors."""
        window = history[-self.PROBE_WINDOW:]
        
        # Collect unique pattern types from suspicious/blocked requests
        unique_patterns = set()
        for record in window:
            if record['threat_level'] != 'safe':
                for pattern in record.get('patterns', []):
                    unique_patterns.add(pattern)
        
        if len(unique_patterns) >= self.PROBE_UNIQUE_THRESHOLD:
            return BehaviorAlert(
                alert_type='probe_sequence',
                severity='critical',
                source_id=source_id,
                description=f'{len(unique_patterns)} distinct attack vectors detected',
                evidence=[{
                    'unique_patterns': sorted(unique_patterns),
                    'window_size': len(window),
                }],
                timestamp=time.time(),
            )
        return None
    
    def get_source_summary(self, source_id: str) -> Dict[str, Any]:
        """Get behavioral summary for a source."""
        history = self.interactions.get(source_id, [])
        if not history:
            return {'source_id': source_id, 'interactions': 0}
        
        safe = sum(1 for r in history if r['threat_level'] == 'safe')
        suspicious = sum(1 for r in history if r['threat_level'] == 'suspicious')
        blocked = sum(1 for r in history if r['threat_level'] == 'blocked')
        
        return {
            'source_id': source_id,
            'interactions': len(history),
            'safe': safe,
            'suspicious': suspicious,
            'blocked': blocked,
            'threat_ratio': round((suspicious + blocked) / len(history), 3),
            'first_seen': history[0]['timestamp'],
            'last_seen': history[-1]['timestamp'],
        }
    
    def get_active_sources(self, since_hours: float = 24) -> List[str]:
        """Get sources active in the last N hours."""
        cutoff = time.time() - (since_hours * 3600)
        active = []
        for source_id, history in self.interactions.items():
            if history and history[-1]['timestamp'] >= cutoff:
                active.append(source_id)
        return active
    
    def clear_source(self, source_id: str) -> bool:
        """Clear interaction history for a source."""
        if source_id in self.interactions:
            del self.interactions[source_id]
            self._save()
            return True
        return False
    
    def stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        total_interactions = sum(len(h) for h in self.interactions.values())
        return {
            'tracked_sources': len(self.interactions),
            'total_interactions': total_interactions,
            'store_path': self.store_path,
        }
